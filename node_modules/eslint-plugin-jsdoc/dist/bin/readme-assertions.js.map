{"version":3,"sources":["../../src/bin/readme-assertions.js"],"names":["trimCode","code","lines","_","trim","split","indendation","length","match","indentSize","map","line","index","slice","join","formatCodeSnippet","setup","paragraphs","push","settings","JSON","stringify","options","errors","message","getAssertions","assertionFiles","glob","sync","path","resolve","__dirname","assertionNames","filePath","basename","assertionCodes","codes","require","invalid","valid","zipObject","updateDocuments","assertions","readmeDocumentPath","documentBody","fs","readFileSync","replace","assertionsBlock","ruleName","ruleAssertions","Error","writeFileSync"],"mappings":";;AAGA;;AACA;;AACA;;AACA;;;;AANA;;;AAQA,IAAMA,QAAQ,GAAG,SAAXA,QAAW,CAACC,IAAD,EAAU;AACzB,MAAIC,KAAK,GAAGC,gBAAEC,IAAF,CAAOH,IAAP,EAAaI,KAAb,CAAmB,IAAnB,CAAZ;;AAEA,MAAMC,WAAW,GAAGJ,KAAK,CAACA,KAAK,CAACK,MAAN,GAAe,CAAhB,CAAL,CAAwBC,KAAxB,CAA8B,MAA9B,CAApB;AAEA,MAAMC,UAAU,GAAGH,WAAW,GAAGA,WAAW,CAAC,CAAD,CAAX,CAAeC,MAAlB,GAA2B,CAAzD;AAEAL,EAAAA,KAAK,GAAGC,gBAAEO,GAAF,CAAMR,KAAN,EAAa,UAACS,IAAD,EAAOC,KAAP,EAAiB;AACpC,QAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,aAAOD,IAAP;AACD;;AAED,WAAOA,IAAI,CAACE,KAAL,CAAWJ,UAAX,CAAP;AACD,GANO,CAAR;AAQA,SAAOP,KAAK,CAACY,IAAN,CAAW,IAAX,CAAP;AACD,CAhBD;;AAkBA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,KAAD,EAAW;AACnC,MAAMC,UAAU,GAAG,EAAnB;AAEAA,EAAAA,UAAU,CAACC,IAAX,CAAgBlB,QAAQ,CAACgB,KAAK,CAACf,IAAP,CAAxB;;AAEA,MAAIe,KAAK,CAACG,QAAV,EAAoB;AAClBF,IAAAA,UAAU,CAACC,IAAX,CAAgB,kBAAkBE,IAAI,CAACC,SAAL,CAAeL,KAAK,CAACG,QAArB,CAAlC;AACD;;AAED,MAAIH,KAAK,CAACM,OAAV,EAAmB;AACjBL,IAAAA,UAAU,CAACC,IAAX,CAAgB,iBAAiBE,IAAI,CAACC,SAAL,CAAeL,KAAK,CAACM,OAArB,CAAjC;AACD;;AAED,MAAIN,KAAK,CAACO,MAAV,EAAkB;AAChBN,IAAAA,UAAU,CAACC,IAAX,CAAgB,iBAAiBF,KAAK,CAACO,MAAN,CAAa,CAAb,EAAgBC,OAAjD;AACD;;AAED,SAAOP,UAAU,CAACH,IAAX,CAAgB,IAAhB,CAAP;AACD,CAlBD;;AAoBA,IAAMW,aAAa,GAAG,SAAhBA,aAAgB,GAAM;AAC1B,MAAMC,cAAc,GAAGC,cAAKC,IAAL,CAAUC,cAAKC,OAAL,CAAaC,SAAb,EAAwB,kCAAxB,CAAV,CAAvB;;AAEA,MAAMC,cAAc,GAAG7B,gBAAEO,GAAF,CAAMgB,cAAN,EAAsB,UAACO,QAAD,EAAc;AACzD,WAAOJ,cAAKK,QAAL,CAAcD,QAAd,EAAwB,KAAxB,CAAP;AACD,GAFsB,CAAvB;;AAIA,MAAME,cAAc,GAAGhC,gBAAEO,GAAF,CAAMgB,cAAN,EAAsB,UAACO,QAAD,EAAc;AACzD;AACA,QAAMG,KAAK,GAAGC,OAAO,CAACJ,QAAD,CAArB;;AAEA,WAAO;AACLK,MAAAA,OAAO,EAAEnC,gBAAEO,GAAF,CAAM0B,KAAK,CAACE,OAAZ,EAAqBvB,iBAArB,CADJ;AAELwB,MAAAA,KAAK,EAAEpC,gBAAEO,GAAF,CAAM0B,KAAK,CAACG,KAAZ,EAAmBxB,iBAAnB;AAFF,KAAP;AAID,GARsB,CAAvB;;AAUA,SAAOZ,gBAAEqC,SAAF,CAAYR,cAAZ,EAA4BG,cAA5B,CAAP;AACD,CAlBD;;AAoBA,IAAMM,eAAe,GAAG,SAAlBA,eAAkB,CAACC,UAAD,EAAgB;AACtC,MAAMC,kBAAkB,GAAGd,cAAKf,IAAL,CAAUiB,SAAV,EAAqB,iBAArB,CAA3B;;AAEA,MAAIa,YAAY,GAAGC,YAAGC,YAAH,CAAgBH,kBAAhB,EAAoC,MAApC,CAAnB;;AAEAC,EAAAA,YAAY,GAAGA,YAAY,CAACG,OAAb,CAAqB,iCAArB,EAAwD,UAACC,eAAD,EAAqB;AAC1F,QAAMC,QAAQ,GAAGD,eAAe,CAACxC,KAAhB,CAAsB,sBAAtB,EAA8C,CAA9C,CAAjB;AACA,QAAM0C,cAAc,GAAGR,UAAU,CAACO,QAAD,CAAjC;;AAEA,QAAI,CAACC,cAAL,EAAqB;AACnB,YAAM,IAAIC,KAAJ,CAAU,uCAAuCF,QAAvC,GAAkD,IAA5D,CAAN;AACD;;AAED,WAAO,gEAAgEC,cAAc,CAACZ,OAAf,CAAuBxB,IAAvB,CAA4B,MAA5B,CAAhE,GACL,2EADK,GACyEoC,cAAc,CAACX,KAAf,CAAqBzB,IAArB,CAA0B,MAA1B,CADzE,GAC6G,UADpH;AAED,GAVc,CAAf;;AAYA+B,cAAGO,aAAH,CAAiBT,kBAAjB,EAAqCC,YAArC;AACD,CAlBD;;AAoBAH,eAAe,CAAChB,aAAa,EAAd,CAAf","sourcesContent":["/**\n * This script is used to inline assertions into the README.md documents.\n */\nimport path from 'path';\nimport fs from 'fs';\nimport _ from 'lodash';\nimport glob from 'glob';\n\nconst trimCode = (code) => {\n  let lines = _.trim(code).split('\\n');\n\n  const indendation = lines[lines.length - 1].match(/^\\s+/);\n\n  const indentSize = indendation ? indendation[0].length : 0;\n\n  lines = _.map(lines, (line, index) => {\n    if (index === 0) {\n      return line;\n    }\n\n    return line.slice(indentSize);\n  });\n\n  return lines.join('\\n');\n};\n\nconst formatCodeSnippet = (setup) => {\n  const paragraphs = [];\n\n  paragraphs.push(trimCode(setup.code));\n\n  if (setup.settings) {\n    paragraphs.push('// Settings: ' + JSON.stringify(setup.settings));\n  }\n\n  if (setup.options) {\n    paragraphs.push('// Options: ' + JSON.stringify(setup.options));\n  }\n\n  if (setup.errors) {\n    paragraphs.push('// Message: ' + setup.errors[0].message);\n  }\n\n  return paragraphs.join('\\n');\n};\n\nconst getAssertions = () => {\n  const assertionFiles = glob.sync(path.resolve(__dirname, '../../test/rules/assertions/*.js'));\n\n  const assertionNames = _.map(assertionFiles, (filePath) => {\n    return path.basename(filePath, '.js');\n  });\n\n  const assertionCodes = _.map(assertionFiles, (filePath) => {\n    // eslint-disable-next-line global-require, import/no-dynamic-require\n    const codes = require(filePath);\n\n    return {\n      invalid: _.map(codes.invalid, formatCodeSnippet),\n      valid: _.map(codes.valid, formatCodeSnippet)\n    };\n  });\n\n  return _.zipObject(assertionNames, assertionCodes);\n};\n\nconst updateDocuments = (assertions) => {\n  const readmeDocumentPath = path.join(__dirname, '../../README.md');\n\n  let documentBody = fs.readFileSync(readmeDocumentPath, 'utf8');\n\n  documentBody = documentBody.replace(/<!-- assertions ([a-z]+?) -->/ig, (assertionsBlock) => {\n    const ruleName = assertionsBlock.match(/assertions ([a-z]+)/i)[1];\n    const ruleAssertions = assertions[ruleName];\n\n    if (!ruleAssertions) {\n      throw new Error('No assertions available for rule \"' + ruleName + '\".');\n    }\n\n    return 'The following patterns are considered problems:\\n\\n````js\\n' + ruleAssertions.invalid.join('\\n\\n') +\n      '\\n````\\n\\nThe following patterns are not considered problems:\\n\\n````js\\n' + ruleAssertions.valid.join('\\n\\n') + '\\n````\\n';\n  });\n\n  fs.writeFileSync(readmeDocumentPath, documentBody);\n};\n\nupdateDocuments(getAssertions());\n"],"file":"readme-assertions.js"}