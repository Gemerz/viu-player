"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _iterateJsdoc.default)(function (_ref) {
  var jsdoc = _ref.jsdoc,
      report = _ref.report,
      functionNode = _ref.functionNode,
      utils = _ref.utils;

  // Implicit return like `() => foo` is ok
  if (functionNode.type === 'ArrowFunctionExpression' && functionNode.expression) {
    return;
  } // Async function always returns a promise


  if (functionNode.async) {
    return;
  }

  var targetTagName = utils.getPreferredTagName('returns'); // We can skip in case there are no tags defined...

  if (typeof jsdoc.tags === 'undefined') {
    return;
  }

  var jsdocTags = jsdoc.tags.filter(function (item) {
    return item.tag === targetTagName;
  });

  if (jsdocTags.length === 0) {
    return;
  }

  if (jsdocTags.length > 1) {
    report('Found more than one @' + targetTagName + ' declaration.');
    return;
  }

  var returnsTagType = jsdocTags[0].type && jsdocTags[0].type.trim();

  if (returnsTagType === 'void' || returnsTagType === 'undefined') {
    return;
  } // An abstract function is by definition incomplete
  // so it is perfectly fine if the return is missing
  // a subclass may inherits the doc an implements the
  // missing return.


  var isAbstract = jsdoc.tags.some(function (item) {
    return item.tag === utils.getPreferredTagName('abstract');
  });

  if (isAbstract) {
    return;
  }

  var sourcecode = utils.getFunctionSourceCode();

  if (sourcecode.indexOf('return') === -1) {
    report('Present JSDoc @' + targetTagName + ' declaration but not available return expression in function.');
  }
});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=requireReturnsCheck.js.map