{"version":3,"sources":["../../src/rules/noUndefinedTypes.js"],"names":["extraTypes","tagsWithNames","context","jsdoc","report","sourceCode","scopeManager","globalScope","typedefDeclarations","getAllComments","filter","comment","_","startsWith","value","map","parseComment","flatMap","doc","tags","tag","includes","name","definedTypes","variables","variable","concat","isModule","childScopes","forEach","parsedType","type","error","node","markVariableAsUsed"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport {parse as parseType, traverse} from 'jsdoctypeparser';\nimport iterateJsdoc, {parseComment} from '../iterateJsdoc';\n\nconst extraTypes = [\n  'null', 'undefined', 'string', 'number', 'boolean', 'any', '*',\n  'Array', 'Object', 'RegExp', 'Date', 'Function'\n];\nconst tagsWithNames = [\n  'callback',\n  'class', 'constructor',\n  'constant', 'const',\n  'event',\n  'external', 'host',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'name',\n  'namespace',\n  'type',\n  'typedef'\n];\n\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  report,\n  sourceCode\n}) => {\n  const scopeManager = sourceCode.scopeManager;\n  const globalScope = scopeManager.globalScope;\n\n  const typedefDeclarations = _(context.getAllComments())\n    .filter((comment) => {\n      return _.startsWith(comment.value, '*');\n    })\n    .map(parseComment)\n    .flatMap((doc) => {\n      return (doc.tags || []).filter((tag) => {\n        return _.includes(tagsWithNames, tag.tag);\n      });\n    })\n    .map((tag) => {\n      return tag.name;\n    })\n    .value();\n\n  const definedTypes = globalScope.variables.map((variable) => {\n    return variable.name;\n  })\n\n    // If the file is a module, concat the variables from the module scope.\n    .concat(scopeManager.isModule() ? globalScope.childScopes[0].variables.map((variable) => {\n      return variable.name;\n    }) : [])\n    .concat(extraTypes)\n    .concat(typedefDeclarations);\n\n  _.forEach(jsdoc.tags, (tag) => {\n    let parsedType;\n\n    try {\n      parsedType = parseType(tag.type);\n    } catch (error) {\n      // On syntax error, will be handled by valid-types.\n      return;\n    }\n\n    traverse(parsedType, (node) => {\n      if (node.type === 'NAME') {\n        if (!_.includes(definedTypes, node.name)) {\n          report('The type \\'' + node.name + '\\' is undefined.', null, tag);\n        } else if (!_.includes(extraTypes, node.name)) {\n          context.markVariableAsUsed(node.name);\n        }\n      }\n    });\n  });\n});\n"],"file":"noUndefinedTypes.js"}