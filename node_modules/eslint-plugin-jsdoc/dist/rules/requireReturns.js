"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _iterateJsdoc.default)(function (_ref) {
  var jsdoc = _ref.jsdoc,
      report = _ref.report,
      utils = _ref.utils;

  if (utils.hasATag([// inheritdoc implies that all documentation is inherited
  // see http://usejsdoc.org/tags-inheritdoc.html
  //
  // As we do not know the parent method, we cannot perform any checks.
  'inheritdoc', 'override', // A constructor function is assumed to return a class instance
  'constructor'])) {
    return;
  }

  if (utils.isConstructor()) {
    return;
  }

  var targetTagName = utils.getPreferredTagName('returns');

  var jsdocTags = _lodash.default.filter(jsdoc.tags, {
    tag: targetTagName
  });

  var sourcecode = utils.getFunctionSourceCode(); // build a one-liner to test against

  var flattenedSource = sourcecode.replace(/\r?\n|\r|\s/g, '');
  var startsWithReturn = '(\\)\\s?\\{return)';
  var endsWithReturn = '(return.*\\})';
  var implicitReturn = '(\\s?=>\\s?\\b.*)';
  var implicitObjectReturn = '(\\s?=>\\s?\\(\\{)';
  var matcher = new RegExp([startsWithReturn, endsWithReturn, implicitObjectReturn, implicitReturn].join('|'), 'gim');
  var positiveTest = (flattenedSource.match(matcher) || []).length > 0;
  var negativeTest = (flattenedSource.match(/(\{.*\{.*return)/gim) || []).length > 0 && (flattenedSource.match(/(return)/gim) || []).length < 2;

  if (JSON.stringify(jsdocTags) === '[]' && positiveTest && !negativeTest) {
    report('Missing JSDoc @' + targetTagName + ' declaration.');
  }
});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=requireReturns.js.map